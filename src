// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import "@openzeppelin/contracts@4.7.2/token/ERC721/ERC721.sol";

import "@openzeppelin/contracts@4.7.2/token/ERC721/extensions/ERC721URIStorage.sol";

import "@openzeppelin/contracts@4.7.2/access/Ownable.sol";

import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

import "@openzeppelin/contracts@4.4.2/utils/Counters.sol";

contract DynamicNFT is ERC721, ERC721URIStorage, Ownable {

  using Counters for Counters.Counter;

  Counters.Counter private _tokenIdCounter;

  string[] IpfsUri = [

     "https://ipfs.io/ipfs/QmRCM8iVPfjbVXGAjicF3mAb45RE5vn7uWxAq3bM3pDgWn",
    "https://ipfs.io/ipfs/QmaP7aurGL#ByjxbigH1Q5V6bmnTkB8dFgdPB1nGGC8Scw",
    "https://ipfs.io/ipfs/Qma23G7YkoodYdHaJeVfsJzWcvEaJc1hFwpwTVQoRpwRHW"
  ];

   uint256 lastTimeStamp;

  uint256 interval;

   constructor(uint _interval) ERC721("dNFTs", "dNFT") {

      interval = _interval;

      lastTimeStamp = block.timestamp;

  }

  function checkUpkeep(bytes calldata /* checkData */) external view  returns (bool upkeepNeeded, bytes memory /* performData */) {

      upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;

      // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.

  }

  function performUpkeep(bytes calldata /* performData */) external  {

      //We highly recommend revalidating the upkeep in the performUpkeep function

      if ((block.timestamp - lastTimeStamp) > interval ) {

          lastTimeStamp = block.timestamp;

          growFlower(0);

      }

      // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function

  }

  function growFlower(uint256 _tokenId) public {

      if(flowerStage(_tokenId) >= 2){return;}

      // Get the current stage of the flower and add 1

      uint256 newVal = flowerStage(_tokenId) + 1;

      // store the new URI

      string memory newUri = IpfsUri[newVal];

      // Update the URI

      _setTokenURI(_tokenId, newUri);

  }

  // determine the stage of the flower growth

  function flowerStage(uint256 _tokenId) public view returns (uint256) {

      string memory _uri = tokenURI(_tokenId);

      // Seed

      if (compareStrings(_uri, IpfsUri[0])) {

          return 0;

      }

      // Sprout

      if (

          compareStrings(_uri, IpfsUri[1])

      ) {

          return 1;

      }

      // Must be a Bloom

      return 2;

  }

  // helper function to compare strings

  function compareStrings(string memory a, string memory b)

      public

      pure

      returns (bool)

  {

      return (keccak256(abi.encodePacked((a))) ==

          keccak256(abi.encodePacked((b))));

  }

   function safeMint(address to) public {

       uint256 tokenId = _tokenIdCounter.current();

       _tokenIdCounter.increment();

       _safeMint(to, tokenId);

       _setTokenURI(tokenId, IpfsUri[0]);

   }

  // The following functions are overrides required by Solidity.

  function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {

      super._burn(tokenId);

  }

  function tokenURI(uint256 tokenId)

      public

      view

      override(ERC721, ERC721URIStorage)

      returns (string memory)

  {

      return super.tokenURI(tokenId);

  }

}
